# Recap

- pointer is just a variable, stores an address of another object
- to get the value, use dereference operator
- sizeof() applied to pointer will get the size of its storage
- ptrs are handy for passing by reference
- NULL by definition unmapped
- array "name" is pointer to the 1st elem
  - not a variable => cannot be modified
- subscripting arrays vs. pointer arith `a[i] = *(a + i)`
- using the pointer variable is using its value, i.e. the address
- ptr dec/increment advances by the size of the underlying type
- addr operator `&` can only be used on variables
- pointers can be subtracted, not added (no sense)
- `void` pointer can be used to assign back and forth
- postfix has higher precedence than deref op however will be evaluated in the
  next sequence
- `errno` variable (of type `int`) signifies the last error of a syscall
  - on Unix see the `errno(3)` man page for possible error codes
  - handy `err()` family of functions (non in the C standard though)
- I/O ops done with file handle
  - fopen/fgets/fclose
  - watch out for resource leaks: [fopen-leak.c](src/fopen-leak.c)

# :wrench: warm-up: implement strcmp()

Implement

    int strcmp(const char *s1, const char *s2);

returns (according to the strcmp(3) manual page)
> an integer greater than, equal to, or less than 0, according as the
> string s1 is greater than, equal to, or less than the string s2.

:eyes: [strcmp.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/strcmp.c)

:wrench: task: compare your solution with the above. Try to reimplement
it so that it is as smallest (in terms of Lines Of Code) as possible.

# Program arguments

```C
int main(int argc, char *argv[]);
```

  - `argv` is declared as an array of pointers
    - i.e. `argv[i]` is a pointer to char
  - the arguments of `main()` can have arbitrary names however please stick
    to the convention to avoid confusion of those who might be reading your
    program

  - `argc` is a number of command line arguments, including the command name
    itself (in `argv[0]`).

  - `argv[i]` are arguments as strings.  Note, they are **strings** even if you put
    numbers there on the command line.

  - `argv[argc]` is NULL by definition.

Note: remember (see
[notes about array passed to function](https://github.com/devnull-cz/c-prog-lang/blob/master/modules/arrays-as-function-arguments.md)
) that in a function argument, an array is
      always treated as a pointer so the above effectively becomes:
```C
        int main(int argc, char **argv);
```
  i.e. in this context, char `*argv[]` and char `**argv` are the same.

  The declaration merely hints at the memory layout.

Also, you already know that you can use an array notation with characters as
well, so you could use `argv[i][j]` to print individual characters.  Just make
sure that it's not out of range.

Code: :eyes: [argv-as-2d-array.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-as-2d-array.c)


- the memory for `argc`, `argv` is allocated before `main()` is called
  - the standard (C99) leaves unspecified where argc/argv are stored

    > section 5.1.2.2.1: the strings pointed to by the argv array shall be
    modifiable by the program, and retain their last-stored values between
    program startup and program termination.

- the `argv` is array of pointers to null-terminated strings and must be
  terminated by a `NULL` pointer. (quote from the execve(2) man page)

```
  argv
  +-----------+
  |           |---------->+--------------+
  +-----------+           |              |---->+---+---+---+---+----+
                          +--------------+     | p | r | o | g | \0 |
                          |              |-\   +---+---+---+---+----+
  argc                    +--------------+  \
  +----------+            |              |-  \->+---+---+---+----+
  |    3     |            +--------------+ \    | f | o | o | \0 |
  +----------+            |     NULL     |  \   +---+---+---+----+
                          +--------------+   \
                                              ->+---+---+---+----+
                                                | b | a | r | \0 |
						+---+---+---+----+
```

:wrench: Task: write a program with usage `./a.out <a> <b> <string>` to
find a distance between the first occurence of character `<a>` and `<b>` in a
string `<string>`.  If either of the character is not found in the string, print
an error.
```
./a.out a x "ahello xworld"
7
```
Note: do not use `strchr()` or the like.

Code: :eyes: [argv-char-dist.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-char-dist.c)

## :wrench: Task: print command line arguments

  - print all command line arguments using `argc`
  - print all command line arguments using just `argv`
  - print all command line arguments not starting with `-`
  - print all command line arguments using a recursive function (that accepts pointer to pointer to char)

Note: for all arguments print their address as well
Note: do not print the terminating `NULL` entry
      - some `printf()` implementations barf on NULL pointer when printing
        via the `%s` format string

Code:
  - :eyes: [argv-while.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-while.c)
  - :eyes: [argv-for.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-for.c)
  - :eyes: [argv-nodash.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-nodash.c)
  - :eyes: [print-argv-recursively.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/print-argv-recursively.c)

## usage: semi-formal specification of program arguments

  - usually used to print when invalid option or arguments are specified
  - can be handled via errx()
  - the usage usually contains program name followed by the argument schema
    - see e.g. the nc(1) man page
  - optional arguments are enclosed in square brackets, mandatory arguments
    are enclosed in `<>` or left without brackets

Task: write a program that takes 1 or 2 arguments, if run with any other count,
      print usage and exit.

Code: :eyes: [usage.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/usage.c)

## :wrench: Task: print the n-th character of the r-rd argument (count from 0)

usage: `./a.out <r> <n> [args]`

do not count `argv[0..2]`.  If not enough arguments or the argument is not long
enough, print a helpful message.  Only use pointer arithmetics, do **not** use
square brackets (ie.  `argv[i][j]` is **not** allowed).
```
./a.out 2 3 hey hi world
l
```
Note: use `atoi()` to convert the first 2 arguments to integers

Code: :eyes: [argv-nr.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-nr.c)

## :wrench: Task: what do these programs do when run with 2 arguments

Assume that the arguments are sufficiently long enough.

```C
	int
	main(int argc, char **argv)
	{
		printf("%s\n", ++*++argv);
	}

	int
	main(int argc, char **argv)
	{
		printf("%s\n", argv[1]);
		printf("%s\n", ++*++argv);
		printf("%s\n", argv[0]);
		printf("%s\n", ++*++argv);
		printf("%s\n", argv[0]);
	}

	int
	main(int argc, char **argv)
	{
		printf("%s\n", *++*++argv);
	}
```

Note: the last function might not compile with smarter compilers (such as LLVM)
that include format string checks.  What is expected to happen if it the last
piece of code does compile and is run with one argument?

Code:
  - :eyes: [plus-deref-plus-argv.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/plus-deref-plus-argv.c)
  - :eyes: [plus-deref-plus-deref-argv.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/plus-deref-plus-deref-argv.c)


# Structures

## Basics

- collection of one or more variables, possibly of different types, grouped
  together under a single name

- structures permit group of related variables to be treated as a unit
  (precursor to a class in Object Oriented Programming)

- structures can contain other structures

- structure is specified as:

```C
    struct foo {
       ... // members
    };
```

e.g.

```C
    struct foo {
    	int a;
    	char b;
    };
```
- any type can be a member of a structure except the structure itself
  - however: a pointer to its own type is possible (remember, a pointer
    is just a number referencing a piece of memory)
  - unlike in C++, structure cannot contain functions. It may contain
    pointers to functions, though.
- structure does not have to have a name, :eyes: [struct-unnamed.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-unnamed.c)
  - however then its use is limited to variable declaration
  - one can even have an "anonymous structure", however that is a C11
    extension, :eyes: [struct-anon.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-anon.c)

- struct declaration cannot contain initializers.  However, the structure can be
  initialized with a list of initializers in the same way as arrays.

- define a variable:
```C
    struct foo foo;
```

- usually the `_s` postfix is used to denote a structure name

 Note: the `struct` keyword has to be used for its definition and declaration:

`foo foo;` is not valid.

- can declare structure and its variables at the same time:

```C
    struct foo_s {
       ...
    } foo;
```

- however usually this is not done because structures are normally saved to
  header files (and including such a header file would mean a variable
  definition which is usually not desirable)

- for better code readability, members are sometimes prefixed with a letter to
  denote their structure type, e.g.:

```C
    // 'sin' is a shortcut for 'Sockaddr_IN', the Internet socket
    // address
    struct sockaddr_in {
	short   sin_family;
        u_short sin_port;
    };
```

- another reason is when looking for variable names in a big source code
  repository (using `ctags` or `cstyle`), there would be large amount of
  generally named variables like `port`, `size`, etc in various source code
  files. However, with the prefix, like `sin_port`, very often you find just
  one, the one you are looking for.

## Struct layout in memory

```C
struct X { int a; char b; int c; };
```

- the offset of the first member will be always 0

- other members can be padded to preserve self-alignment (i.e. member is always
  aligned in memory to multiple of its own size)
	- the value of the padding bits is undefined

- what will be the result of `sizeof (struct X)` ?
	- why ? (think about efficiency of accessing members that cross
	  a word in memory)

- what if `char d` is added at the end of the data structure ?
	- why is that ? (think about arrays and memory access again)

- what if `char *d` is added at the end of the data structure ?  (i.e.  it will
  have 4 members)
	- assume this is being compiled on 64-bit machine
	- for efficiency the access to the pointer should be aligned to its size
	- if in doubt, draw a picture

```
	+-----------+----+--------+------------+
	|     a     | b  |   pad  |      c     |
	+-----------+----+--------+------------+
```

- does the compiler reorder struct members ? no, C is designed to trust the
  programmer.

code: :eyes: [struct-X.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-X.c)

note: gcc/Clang has the `-fpack-struct` option that will condense the members at
the expense of speed when accessing them.  Use only when you know what you are
doing as it may not be safe on all architectures.

link: http://www.catb.org/esr/structure-packing/

## Struct members

- members are accessed via 2 operators: `.` and `->`
	- infix, in the group of operators with the highest precedence
	- `->` is used if the variable is a pointer, `.` otherwise

- e.g.:

```C
  struct foo_s {
	int a;
	char b;
  } foo;

  foo.a = 42;
  foo.b = 'C';
```
- the `.` and `->` operators have higher precedence than `*` and `&`, so:

    `&foo.b` gets the address of the member `b`

code: :eyes: [struct-reference.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-reference.c)

- structure assignment

```C
    struct foo_s one, two;

    one = two;
```
- is done byte by byte (shallow copy - does not follow pointers)
	- handy for members that are pointers
	- on the other hand for large structures (say hundreds of bytes) this
	  can be quite an expensive operation

- pointers to structures:
```C
    struct foo_s *foo;

    foo->a = 42;
    foo->b = 'C';
```
:wrench: Task: write the above assignments using a de-reference operator on
`foo`

code: :eyes: [struct-access.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-access.c)

:wrench: now if `a` was a pointer to integer, how would the code change ?

## Struct initialization

- can initialize in definition using the initiator list of **constant** values

```C
    struct foo_s {
       int a;
       char b;
    };

    struct foo_s foo = { 1, 'C' };
```

code: :eyes: [struct-init.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-init.c)

- or using 'designated initializers' from C99:

```C
    struct foo_s foo = {
            .b = 'C',
            .a = 1
    };
```

- the ordering in the struct declaration does not have to be preserved

- omitted field members are implicitly initialized the same as objects that have
  static storage duration (ie. will be initialized to 0).

code: :eyes: [struct-designated-init.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-designated-init.c)

## Operations on structures

You can only:

- copy a structure
- assign to it as a unit
- taking its address with &
- access its members

So, structures cannot be:

- compared
- incremented (obviously)

## Opaque structures

It is possible to declare structure in a header file along with API that
consumes it:

```C
// foo.h
struct foo;
void doStuff(struct foo *f);
```

the file implementing `doStuff()` will contain:

```C
struct foo {
    int x;
    int y;
};

void
doStuff(struct foo *f)
{
	f->x = ...
	f->x = ...
}
```

Then any `.c` file that includes `foo.h` can work with the structure
(by passing it to `doStuff()`) however cannot access its members directly.
The structure is usable only via pointer. Thus, the library has to provide
a function to allocate a structure and return the pointer to it
(and possibly also to initialize it).

This is handy for libraries so they are free to change the layout of structures
without breaking the consumers.

code:
  - :eyes: [foo.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo.h)
  - :eyes: [foo.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo.c)
  - :eyes: [foo-user.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo-user.c)

## :wrench: Task: animals as structures

define array of structures of this type:

```C
        struct animal {
           char name[NAME_MAX]; // max filename length should be sufficient
				// even for these long Latin names
           size_t legs;		// can have many legs
        };
```

and initialize it with some samples (can store the array in animals.h) and
implement a function:

```C
      size_t count_minlegs(struct animal *, size_t len, size_t min);
```

that will return number of animals in the array (of `len` items) that have at
least `min` legs.

Notice that the function returns `size_t`. This way it is ready for future
expansion. If it returned unsigned int and 32-bits was not found enough later
on, the prototype would have to be changed which would cause problems for the
consumers of this API.

The function will be implemented in a separate file.  (Do not forget to create a
header file(s).)

In the `main()` program (first arg will specify the `min` parameter of the
function) pass the array of structs to the function and report the result.

Note: will need:

- `limits.h` for the `NAME_MAX` definition
- `stddef.h` for `size_t` (as per C99, §7.17)

code:
  - :eyes: [struct-animals.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-animals.c)
  - :eyes: [animal\_minlegs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animal\_minlegs.c)
  - :eyes: [animal.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animal.h)
  - :eyes: [animals.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animals.h)

Note: for compilation it is only necessary to compile the `*.c` files and then
link them together.

It can be done e.g. like this:

      cc struct-animals.c animal_minlegs.c

where the compiler will do the compilation of the individual object files and
then call the linker to contruct the binary (named `a.out`).

Or like this:

      cc -c struct-animals.c animal_minlegs.c
      cc -o animals struct-animals.o animal_minlegs.o

which is closer to what would be done using Makfile.

Technically, `animals.h` contains code, however, given it is included in a `.c`
file it is not necessary to compile it individually.

:wrench: Task: use the code from previous task and implement (in separate `.c`
file)

      static size_t getlegs(struct animal *);

that will return number of legs for a given animal.

### animals: maximum number of legs

implement:

      struct animal *maxlegs(struct animal *, size_t len);

that will use the `getlegs()` function and will return an animal with highest
leg count. Return pointer to the structure (= array element) from the function.

The `main()` function (in separate file) will define an array of animals and
will call `maxlegs()`.  The name of the animal with maximum number of legs will
be printed to standard output.

Note: does the original structure change if the structure returned from the
function was modified within the function? How to fix this ?

code:
  - :eyes: [animal\_maxlegs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animal\_maxlegs.c)
  - :eyes: [maxlegs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/maxlegs.c)
  - :eyes: [animals.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animals.h)
  - :eyes: [animal.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animal.h)

### :wrench: animal sorting

:wrench: (home) Task: sort the array by number of legs, print it out to standard
output.

:wrench: Task: sort the array by the animal name. Print it out to standard
output.  Use `strcmp()` to do the comparison of names.

:wrench: Task: add a function that will sort according to the number of legs

Make the comparison functions static.

Use the standard libc sort function qsort(3).  Check the manual page on how it's
used.  You will need to define a callback function that the qsort() function
will use to compare two array elements.

Make the program to accept an argument (0 or 1) and run the sorting function
based on that.

code:
  - :eyes: [animal-sort.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animal-sort.c)
  - :eyes: [animals.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animals.h)
  - :eyes: [animal.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/animal.h)

## Pointer to a structure and type casting

- pointers to structures are often used to achieve common interface for
  different types

  - e.g.

```C
    struct Common { int type; };
    struct A      { int type; char data[8]; };	// type == 1
    struct B      { int type; char data[16]; }; // type == 2
```
  - then a function can be declared like so:
```C
    int func(struct Common *c);
```
  - internally it can do e.g.:
```C
    if (c->type == 1) {
    	struct A *ap = (struct A *)c;
	ap->data[7] = 'A';
    } else if (c->type == 2) {
    	struct B *bp = (struct B *)c;
	ap->data[15] = 'B';
    }
```
  - this is possible since all the structures have the same member
    on the same offset (that is offset 0)

code: :eyes: [struct-common.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-common.c)

Or, more commonly, a function will allocate a `A` or `B` structure and return
its address as pointer to the `Common` struct. This pointer then needs to be
casted according to its first member.

See `struct sockaddr`, `struct sockaddr_in` and `struct sockaddr_in6`
definitions for example on how this is done in practice.

:wrench: task: write a macro (or start with a function with hardcoded values)
that will print the offset of the specified member of a given structure.

      offsetof(struct X, a)

hint: exploit the fact that pointer can be assigned an integer (0) + use pointer
arithmetics

note: `offsetof()` is standard macro available since ANSI C via stddef.h

code: :eyes: [offsetof.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/offsetof.c)

## bit fields

- sometimes memory in struct is scarce (imagine having to keep thousands of big
  structures in memory) and there are members holding integers than occupy just
  a couple of bytes
  - bit fields can be used to shrink the memory needed
```C
struct foo {
	unsigned int a : 3;
	unsigned int b : 1;
	unsigned int   : 4;
};
```
 - the number after the colon specifies the number of bits for given bit field
   - cannot exceed the size of the underlying data type (`unsigned int` in the
     above example)

 - this is good for implementing network protocol headers or HW registers,
   however the layout of bit fields in C structure is implementation dependent
   - if it needs to match a concrete layout, additional non-standard compiler
     features have to be used (`#pragma`'s etc.)
   - there is no `offsetof()` for bit fields

code: :eyes: [bitfield.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/bitfield.c)

- the integer values will behave as expected, e.g.
```C
  unsigned int a : 3;

  a = 7;
  a++; // will wraparound to 0 since this is unsigned
```

:wrench: task: declare a structure that will form a simple linked list and will
hold an integer as a value. The program will be run with a single argument
specifying how many items the list will have.

Allocate a new structure and insert into the head (global variable).  Each new
item will have its value incremented by one.

Once the list is complete, print its value by traversing its items from head to
end.

code: :eyes: [linked-list-free.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/linked-list-free.c)

## flexible array member

- since C99 (§6.7.2.1, item 16, page 103)
- it is an array without a dimension specified that is the last member of the
  structure
  - this is handy for structures with a fixed header and "padding" data of
    flexible length that is allocated dynamically
  - why not to use a pointer instead ? this is good when passing data over
    boundaries such as network, kernel/userland, etc. since no deep
    structure copy is required

- e.g.:
```C
  struct item {
      int value;
      // possible other members
      char payload[];
      // nothing can follow
  };
```

- `sizeof (struct item)` will give the size without the last member computed

```
	+-------------+-----------------------+
	| struct item |      payload ...      |
	+-------------+-----------------------+
```

- previously, this was hacked around using array with 0 members and GCC accepted
  this. Since C99 this can be done properly using this technique.
- the data is allocated like so:

```C
    struct item *p = malloc(sizeof (struct item) +
        payload_len * sizeof (p->payload[0]));
```

- with this approach the overall structure alignment might be lost
  - i.e. it is necessary to set the payload length according to the size
    of the structure if you want to maintain alignment

code: :eyes: [flexible-array-member.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/flexible-array-member.c)

# Operator precedence

There are 15 levels of operator precedence,
see the table on http://en.cppreference.com/w/c/language/operator_precedence

## Examples

`*p++` is `*(p++)` as `++` is of higher priority than `*`.  However, the value of the expression
is still `*p` though as `p` is incremented after the expression is evaluated.

:wrench: Task: determine the outcome of these expressions/declarations:
  - `*p++`
  - `++*p`
  - `int *p[2]`
  - `int (*p)[3]`

## Associativity

If there are multiple operators with the same precedence in an expression,
the evaluation is decided based on associativity.

For example:
```C
8 / 2 % 3
```
has 2 operators with precedence level of 3 that have left-to-right
associativity. Therefore, they will be evaluated as
```C
(8 / 2) % 3
```

## Operand evaluation order

Consider the following:

```C
int foo(void);
int bar(void);

int x = foo() + bar();
```

The standard does not say how the evaluation will be done. `foo()` can be called
before or after `bar()`. If we add another function:

```C
int foo(void);
int bar(void);
int another(void);

int x = foo() + bar() + another();
```

then the expression will become `(foo() + bar()) + another()` however the order
in which `foo()` and `bar()` will be called is still undefined.

## Common gotchas

### `==` or `!=` versus `=`

the condition in the statement:
```C
if ((c = getchar()) != 0)
    ...
```

needs to be bracketed this way because `=`/`!=` has higher precedence than `=`.

### `&` or `*` versus `->` or `.`

`->` and `.` (structure member access) have higher precedence than `&` (address
of) or `*` (dereference)

:wrench: condsider structure
```C
struct bar {
	int val;
} bar;

struct {
	int a[42];
	char *b;
	struct bar *c;
} foo;
```
initialize members of `foo` with `1, 2, 3` and `"BBB"`, respectively and
`bar` with `42`. Use designated initializers.

write these expressions to get:
  - the address of `a`
  - the address of `b`
  - the address of the second item of `a`
  - the address of the 3rd character from string `b`
  - the 3rd character from string `b`
  - value of `val` in `bar` using `foo`
  - address of `val` in `bar` using `foo`

Use as few brackets as possible.

solution: :eyes: [struct-op-precedence.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/struct-op-precedence.c)

