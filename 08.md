# Recap

- pointer is just a variable, stores an address of another object
- to get the value, use dereference operator
- sizeof() applied to pointer will get the size of its storage
- ptrs are handy for passing by reference
- NULL by definition unmapped
- array "name" is pointer to the 1st elem
  - not a variable => cannot be modified
- subscripting arrays vs. pointer arith `a[i] = *(a + i)`
- using the pointer variable is using its value, i.e. the address
- ptr dec/increment advances by the size of the underlying type
- addr operator `&` can only be used on variables
- pointers can be subtracted, not added (no sense)
- `void` pointer can be used to assign back and forth
- postfix has higher precedence than deref op however will be evaluated in the
  next sequence
- `errno` variable (of type `int`) signifies the last error of a syscall
  - on Unix see the `errno(3)` man page for possible error codes
  - handy `err()` family of functions (non in the C standard though)
- I/O ops done with file handle
  - fopen/fgets/fclose
  - watch out for resource leaks: [fopen-leak.c](src/fopen-leak.c)

# Program arguments

```C
int main(int argc, char *argv[]);
```

  - `argv` is declared as an array of pointers
    - i.e. `argv[i]` is a pointer to char
  - the arguments of `main()` can have arbitrary names however please stick
    to the convention to avoid confusion of those who might be reading your
    program

  - `argc` is a number of command line arguments, including the command name
    itself (in `argv[0]`).

  - `argv[i]` are arguments as strings.  Note, they are **strings** even if you put
    numbers there on the command line.

  - `argv[argc]` is NULL by definition.

Note: remember (see lecture 07 notes) that in a function argument, an array is
      always treated as a pointer so the above effectively becomes:
```C
        int main(int argc, char **argv);
```
  i.e. in this context, char `*argv[]` and char `**argv` are the same.

  The declaration merely hints at the memory layout.

Also, you already know that you can use an array notation with characters as
well, so you could use `argv[i][j]` to print individual characters.  Just make
sure that it's not out of range.

Code: :eyes: [argv-as-2d-array.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-as-2d-array.c)


- the memory for `argc`, `argv` is allocated before `main()` is called
  - the standard (C99) leaves unspecified where argc/argv are stored

    > section 5.1.2.2.1: the strings pointed to by the argv array shall be
    modifiable by the program, and retain their last-stored values between
    program startup and program termination.

- the `argv` is array of pointers to null-terminated strings and must be
  terminated by a `NULL` pointer. (quote from the execve(2) man page)

```
  argv
  +-----------+
  |           |---------->+--------------+
  +-----------+           |              |---->+---+---+---+---+----+
                          +--------------+     | p | r | o | g | \0 |
                          |              |-\   +---+---+---+---+----+
  argc                    +--------------+  \
  +----------+            |              |-  \->+---+---+---+----+
  |    3     |            +--------------+ \    | f | o | o | \0 |
  +----------+            |     NULL     |  \   +---+---+---+----+
                          +--------------+   \
                                              ->+---+---+---+----+
                                                | b | a | r | \0 |
						+---+---+---+----+
```

:wrench: Task: find a distance between the first occurence of character `<a>` and `<b>` in a
string `<string>`.  If either of the character is not found in the string, print
an error.
```
./a.out a x "ahello xworld"
7
```
Note: do not use `strchr()` or the like.

Code: :eyes: [argv-char-dist.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-char-dist.c)

-------------------------------------------------------------------------------

:wrench: Task:

  - print all command line arguments using `argc`
  - print all command line arguments using just `argv`
  - print all command line arguments not starting with `-`
  - print all command line arguments using a recursive function (that accepts pointer to pointer to char)

Note: for all arguments print their address as well
Note: do not print the terminating `NULL` entry
      - some `printf()` implementations barf on NULL pointer when printing
        via the `%s` format string

Code:
  - :eyes: [argv-while.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-while.c)
  - :eyes: [argv-for.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-for.c)
  - :eyes: [argv-nodash.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-nodash.c)
  - :eyes: [print-argv-recursively.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/print-argv-recursively.c)

-------------------------------------------------------------------------------

:wrench: Task: print the n-th character of the r-rd argument (count from 0), do not
count `argv[0..2]`.  If not enough arguments or the argument is not long enough,
print a helpful message.  Only use pointers, do NOT use square brackets (ie.
`argv[i][j]` is NOT allowed).
```
./a.out 2 3 hey hi world
l
```
Note: use atoi() to convert the first 2 arguments to integers

Code: :eyes: [argv-nr.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-nr.c)

-------------------------------------------------------------------------------

- usage: semi-formal specification of program arguments
  - usually used to print when invalid option or arguments are specified
  - can be handled via errx()
  - the usage usually contains program name followed by the argument schema
    - see e.g. the nc(1) man page
  - optional arguments are enclosed in square brackets, mandatory arguments
    are enclosed in `<>` or left without brackets

Task: write a program that takes 1 or 2 arguments, if run with any other count,
      print usage and exit.

Code: :eyes: [usage.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/usage.c)

-------------------------------------------------------------------------------

:wrench: Task: what do these programs do when run with 2 arguments (that are
sufficiently long enough):

```C
	int
	main(int argc, char **argv)
	{
		printf("%s\n", ++*++argv);
	}

	int
	main(int argc, char **argv)
	{
		printf("%s\n", argv[1]);
		printf("%s\n", ++*++argv);
		printf("%s\n", argv[0]);
		printf("%s\n", ++*++argv);
		printf("%s\n", argv[0]);
	}

	int
	main(int argc, char **argv)
	{
		printf("%s\n", *++*++argv);
	}
```

Note: the last function might not compile with smarter compilers (such as LLVM)
that include format string checks.  What is expected to happen if it the last
piece of code does compile and is run with one argument?

Code:
  - :eyes: [plus-deref-plus-argv.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/plus-deref-plus-argv.c)
  - :eyes: [plus-deref-plus-deref-argv.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/plus-deref-plus-deref-argv.c)



TODO: structures (for tar as well)

# Operator precedence

`*p++` is `*(p++)` as `++` is of higher priority than `*`.  However, the value of the expression
is still `*p` though as `p` is incremented after the expression is evaluated.

:wrench: Task: determine the outcome of these expressions/declarations:
  - `*p++`
  - `++*p`
  - `int *p[2]`
  - `int (*p)[3]`

See the table on http://en.cppreference.com/w/c/language/operator_precedence

