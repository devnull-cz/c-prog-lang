# Pointer addressing

Like with arrays, it is possible to subscript pointers:

```C
int a[10];
int *p = a;

p[0]...
```

This just goes directly fromt the standard: `p[x]` is equivalent to `*(p + x)`.
And remember that incrementing a pointer or an array expression goes by
increments of the element type size.

```C
int a[2] = { 1, 222 };

/* Will print 222. */
printf("%d\n", *(a + 1));
```

# Array of pointers

See also #module program-arguments.md

```C
/*
 * [] is of higher precedence than *, so the following means:
 *
 *	 "a is an array of 10 pointers to char"
 */
char *a[10];
```

You could write it as `char *(a[10])` but that would be quite uncommon and is
not recommended.

You can initialize such an array the same way as before.  Remember, a string
literal is internally an array of `char`s, so we can use it to initialize the
following array of `char` pointers (it is the same as `char *p = a`).

```C
char *a[] = { "hello", "world", "!" };
```

:eyes: [array-of-ptrs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/array-of-ptrs.c)

:wrench:
- Define two integers `i`, `j` and initialize them with some arbitrary values.
- Define an array `a` of pointers to `int` that contains pointers to these two
  integers.
- Define an array `b` of `int`s that will contain the values of these two
  integers.
- Define a pointer `p`, and assign i-th element of array `a` to it.
- Define a pointer `q`, and assign an address of the i-th element of array `b`
  to it.
- Print the address of `p`, `q` and then deference them.

What you are expected to get when dereferencing the `p` and `q` pointers?

What is the distance between these 2 pointers?  Does it make sense to do that?
A difference between two pointers is a signed integer of type `ptrdiff_t`.  To
print it out via `printf`, use a `t` modifier.

```C
int a[2];
int *p = &a[1];
int *q = &a[0];

printf("%td\n", p - q);
```

What is a reasonable value of the 1st argument (`i`)?

Usage: `./a.out <i>`

:eyes: [ptr-to-array-of-ptrs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/ptr-to-array-of-ptrs.c)

# Pointer to a pointer

We know that a pointer points to an object (unless its a `NULL` pointer or of
type `void`), eg. an `int`.  However, the object may be another address, i.e.
a pointer may point to another pointer.

```C
int i = 13;
int *pi = &i;
int **ppi = &pi;        // ppi is a pointer to a pointer to an int

// *pi is a pointer to an int, so another dereference is needed to get the value
printf("%d\n", **pi);   // prints 13
```

## A pointer to a pointer to an array vs. a pointer to an array of pointers

Imagine this: let's assume we have an array of pointers to an integer, like
this:

```C
int *p[10];     // note it is equivalent to "int *(p[10])"
```

Now, let's have a function takes an array of `int` pointers and prints the
array's n-th element.  We know that when passing an array as an argument, C
converts it to a pointer.   So, `int *p[]` can be written as `int **p`.

```C
void
foo(int **p, size_t idx)
{
        printf("%d\n", **(p + idx));
}
```

Clearly, this works fine in a situation when `pp` is indeed a pointer to an
array of integer pointers (left).  Now what if someone passes a pointer to a
pointer to an integer array (right)?

Note that in both situations, `ppa` and `ppb` **properly fit the declaration**
`int **p`.

           +-------+     +-------+     +-------+
         i |   42  |   j |   7   |   k |   99  |
           +-------+     +-------+     +-------+
               ^           /      _______/
               |         /       /
           +-------+-------+-------+           +------+------+------+
         a |   &i  |   &j  |   &k  |         b |  42  |   7  |  99  |
           +-------+-------+-------+           +------+------+------+
               ^                                   ^
               |                                   |
           +-------+                           +------+.......
       ppa |   a   |                        pb |   b  |   ?  :
           +-------+                           +------+.......
                                                   ^
                                                   |
                                               +------+
                                           ppb |  pb  |
                                               +------+

What is the difference in accessing the values?  I.e. what will `**(x + 1)` and
`*(*x + 1)` do when `x` is `ppa` or `ppb`?

:eyes: [ptr-ptr-array.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/ptr-ptr-array.c)

This is from a real-life problem, quoting from https://unixpapa.com/incnote/pam.html:

> When the conversation function is called, it is passed an array of prompts.
> This is always passed in as struct pam\_message `**mesg`. However, the
> interpretation varies. In Linux-PAM and OpenPAM this is a pointer to an array
> of pointers to pam\_message structures, whereas in Solaris it is a pointer to a
> pointer to an array of pam\_message structures. Frequently there is only one
> prompt being passed in, so it doesn't matter. Under either interpretation, the
> first structure is addressable as `**msg`. However, accessing subsequent
> elements is different. In Linux-PAM and OpenPAM, the second element is at
> `*(msg[2])`, while in Solaris it is at `(*msg)[2]`.

# Changing pointers

- in order to change the value of a pointer in a function, it has to be passed
  as a pointer to a pointer
  - this makes sense, because the storage address of a plain pointer is not
    known to the function, and therefore we must pass in its address so that we
    can change the object the address points to by dereferencing the address.

:eyes: [ptr-change.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/ptr-change.c)

# Explicit type conversion

We already saw an implicit conversion when working with integer types.

Casting is an explicit type conversion:

```C
(type_name)expression;

int i = 13;
long l = (long)i;		// Just an example.  The casting not needed in this
				// case, the implicit integer conversion would
				// work fine.
```

Casting is used to avoid compiler warnings as a sort of a hint to the compiler
that you know what you are doing.

:eyes: [cast-double.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/cast-double.c)

Explicit cast for pointers of different types works:

(C2011, 6.3.2.3/7)

> A pointer to an object type may be converted to a pointer to a different
> object type.  If the resulting pointer is not correctly aligned for the
> referenced type, the behavior is undefined.  Otherwise, when converted back
> again, the result shall compare equal to the original pointer.

This will be esp. handy for pointers to structures.

The cast itself is not a problem, it depends on what will be done with the
result.

:eyes: [ptr-cast.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/ptr-cast.c)

`void *` is a special pointer that cannot be dereferenced.  You can always
assign any pointer to a `(void *)` pointer without any need for casting, and you
can also assign any `(void *)` pointer to any other pointer without any need for
casting.  These assignments are **guaranteed to not lose any information**.

```C
int i = 99;
void *p = &i;
int *pi = p;

printf("%d\n", *pi);	// will print 99
printf("%d\n", *p);	// will error out when compiled
```

Verify that a staticly allocated 2D array is stored in one piece of memory, row
by row.  Hint: you need to recast a 2D array to a 1D array, then print it as a
single row.  There are a few different ways to do it.  Do not look at the
solution until you write your own code.

```C
int a[5][5] = { ... };
// ...
```

:eyes: [2d-static-array-as-1d.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/2d-static-array-as-1d.c)

# heap/dynamic allocation: malloc()/free()

The memory automatically allocated for local variables and function parameters
is allocated in an area called a *stack*. There is an area called a *heap* to
allocate memory that lasts after the function returns. This is also called
*dynamic allocation*.

The allocator in the standard library offers the
`malloc`()/`calloc`()/`free`()/...  APIs for heap allocation.

The `malloc`/`calloc` functions return a pointer to a memory area of a specified
size or a `NULL` pointer if the allocation failed - always check that!  (even on
Linux where it seems it can never fail - to be prepared for change in a
configuration and also for portability to systems with more conservative memory
allocation).

```C
#define	ARRLEN	20
int *p;

if ((p = malloc(ARRLEN * sizeof (int))) == NULL)
	err(1, "malloc");
p[0] = 99;
p[ARRLEN - 1] = 77;
```

The prototype for `malloc` is as follows:

```C
void *malloc(size_t size);
```

Note that as `malloc` returns `void *`, there is no need to explicitly type its
result when assigned to a pointer.  That is, do not use:

```C
int *p;

p = (int *)malloc(16);
```

See `man malloc` for more memory allocation related functions.

# Memory leaks

The C runtime does not have a garbage collector so all heap allocated memory has
to be explicitly freed via `free`() after it is no longer needed.  If not freed,
that creates a resource leak called a *memory leak*.  Depending on the problem
this might cause the problem of running out of memory later on (and then
`malloc`/`calloc` can start returning `NULL`).

The leaks can be checked using static or dynamic analyzers.

:wrench: write a program that takes all arguments that follow `argv[0]`,
concatenates them (without the terminating `NUL` character) into one string
dynamically allocated via `malloc`() and prints this string to the standard
output.

  - the concatenation can be done either by hand (try that first) or strncat()
    (try that afterwards)

:eyes: [argv-concat.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/argv-concat.c)

You can then put the string processing in a loop and comment out the `free`()
call on the allocated memory.  Then check out with `top` that the memory size of
the running program quickly increases.

