# Pointer addressing

Like with arrays, it is possible to subscript pointers:

```C
int a[10];
int *p = a;

p[0]...
```

This just goes directly fromt the standard: `p[x]` is equivalent to `*(p + x)`.
And remember that incrementing a pointer or an array expression goes by
increments of the element type size.

```C
int a[2] = { 1, 222 };

/* Will print 222. */
printf("%d\n", *(a + 1));
```

# Array of pointers

See also #module program-arguments.md

```C
/*
 * [] is of higher precedence than *, so the following means:
 *
 *	 "a is an array of 10 pointers to char"
 */
char *a[10];
```

You could write it as `char *(a[10])` but that would be quite uncommon and is
not recommended.

You can initialize such an array the same way as before.  Remember, a string
literal is internally an array of `char`s, so we can use it to initialize the
following array of `char` pointers (it is the same as `char *p = a`).

```C
char *a[] = { "hello", "world", "!" };
```

:eyes: [array-of-ptrs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/array-of-ptrs.c)

:wrench:
- Define two integers `i`, `j` and initialize them with some arbitrary values.
- Define an array `a` of pointers to `int` that contains pointers to these two
  integers.
- Define an array `b` of `int`s that will contain the values of these two
  integers.
- Define a pointer `p`, and assign i-th element of array `a` to it.
- Define a pointer `q`, and assign an address of the i-th element of array `b`
  to it.
- Print the address of `p`, `q` and then deference them.

What you are expected to get when dereferencing the `p` and `q` pointers?

What is the distance between these 2 pointers?  Does it make sense to do that?
A difference between two pointers is a signed integer of type `ptrdiff_t`.  To
print it out via `printf`, use a `t` modifier.

```C
int a[2];
int *p = &a[1];
int *q = &a[0];

printf("%td\n", p - q);
```

What is a reasonable value of the 1st argument (`i`)?

Usage: `./a.out <i>`

:eyes: [ptr-to-array-of-ptrs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/ptr-to-array-of-ptrs.c)

# Pointer to a pointer

We know that a pointer points to an object (unless its a `NULL` pointer or of
type `void`), eg. an `int`.  However, the object may be another address, i.e.
a pointer may point to another pointer.

```C
int i = 13;
int *pi = &i;
int **ppi = &pi;        // ppi is a pointer to a pointer to an int

// *pi is a pointer to an int, so another dereference is needed to get the value
printf("%d\n", **pi);   // prints 13
```

## A pointer to a pointer to an array vs. a pointer to an array of pointers

Imagine this: let's assume we have an array of pointers to an integer, like
this:

```C
int *p[10];     // note it is equivalent to "int *(p[10])"
```

Now, let's have a function takes an array of `int` pointers and prints the
array's n-th element.  We know that when passing an array as an argument, C
converts it to a pointer.   So, `int *p[]` can be written as `int **p`.

```C
void
foo(int **p, size_t idx)
{
        printf("%d\n", **(p + idx));
}
```

Clearly, this works fine in a situation when `pp` is indeed a pointer to an
array of integer pointers (left).  Now what if someone passes a pointer to a
pointer to an integer array (right)?

Note that in both situations, `ppa` and `ppb` **properly fit the declaration**
`int **p`.

           +-------+     +-------+     +-------+
         i |   42  |   j |   7   |   k |   99  |
           +-------+     +-------+     +-------+
               ^           /      _______/
               |         /       /
           +-------+-------+-------+           +------+------+------+
         a |   &i  |   &j  |   &k  |         b |  42  |   7  |  99  |
           +-------+-------+-------+           +------+------+------+
               ^                                   ^
               |                                   |
           +-------+                           +------+.......
       ppa |   a   |                        pb |   b  |   ?  :
           +-------+                           +------+.......
                                                   ^
                                                   |
                                               +------+
                                           ppb |  pb  |
                                               +------+

What is the difference in accessing the values?  I.e. what will `**(x + 1)` and
`*(*x + 1)` do when `x` is `ppa` or `ppb`?

:eyes: [ptr-ptr-array.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/ptr-ptr-array.c)

This is from a real-life problem, quoting from https://unixpapa.com/incnote/pam.html:

> When the conversation function is called, it is passed an array of prompts.
> This is always passed in as struct pam\_message `**mesg`. However, the
> interpretation varies. In Linux-PAM and OpenPAM this is a pointer to an array
> of pointers to pam\_message structures, whereas in Solaris it is a pointer to a
> pointer to an array of pam\_message structures. Frequently there is only one
> prompt being passed in, so it doesn't matter. Under either interpretation, the
> first structure is addressable as `**msg`. However, accessing subsequent
> elements is different. In Linux-PAM and OpenPAM, the second element is at
> `*(msg[2])`, while in Solaris it is at `(*msg)[2]`.

