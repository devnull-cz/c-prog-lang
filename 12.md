# :wrench: Warm-up: bit difference

Task: write a program that counts the number of bits that need to be flipped so
      that number A becomes number B.

Note: use the character representation only for debug prints. The actual
      operations with the numbers are to be done with bit operations on
      integers.

Note: consider only positive integers, assume `int`.

:eyes: [bitdiff.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/bitdiff.c)
:eyes: [binprint.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/binprint.c)

Sub-task for home: flip those bits and verify that the numbers are the same.

# :wrench: Warm-up: Number of bits for binary representation

Given an `int`, find out (using bit operators) how many bits (characters) will
be needed to represent the number in binary. Then rewrite
:eyes: [binprint.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/binprint.c)
using the acquired number.

Note: little vs big endian


# Functions with variable arguments

:wrench: write a function that takes variable number of `ULL` arguments
  and returns their sum

  - use the stdarg(3) man page
  - what happens if there is a one `int` value passed in between the `ULL`
    arguments ?

solution: [stdarg.c](src/stdarg.c)


# Linking objects

Larger programs are often split into many source code files. One can create the
binary like so:
```
  cc -o binary foo.c bar.c ...
```
and it will work however the files will be compiled every time even though they
were not changed.

To save time the files are usually compiled individually and then linked
into the binary using _runtime linker_ (sometimes called _link editor_),
a program usually called `ld`. This program also takes care of adding
dependencies on dynamic libraries to the resulting binary.

It works like this (assuming all source code files changed):
```
  cc -c foo.c
  cc -c bar.c
  ...
  cc -o binary foo.o bar.o ...
```

Note that the program `ld` was not invoked directly, it is the compiler that
serves as a `ld` wrapper as it needs to add more object files with C runtime
under the hood.


# Debugging

## Debug prints

- the most primitive debugging technique is to insert debug prints
- `fprintf()`
  - do not use `printf()` for debugging unless you know what you are doing
  - use a unique text for each debug text, for example:
```C
	/* some code */
	fprintf(stderr, "DBG 1\n");
	/* some code */
	fprintf(stderr, "DBG 2\n"); ...
	/* some code */
	fprintf(stderr, "DBG 3\n"); ...
	...
```
    - if you need to put another debug message in between 1 and 2, "1.5"
      seems like an easy way to do it.

## System call tracing

- system calls: interface to the kernel to provide services like memory
  allocation, I/O, ...
- prints system call arguments, return values, timing information etc.
- this works by inserting break points
  - the break points make the program slower, this overhead could be much larger
    than what is allowed in production

- basic tools:
  - `strace`/`truss`/`ltrace`
  - `dtrace` (dynamic tracing)

:wrench: Task: write a program that opens a file specified by the first argument
  of the program and reads number of bytes specified by the second argument and
  writes them to standard output. Use fopen()/fread() without checking return
  values or error conditions.  What happens if the program tries to read files
  like `/etc/shadow` on Unix ?  Run the program under strace to see possible
  clues. Refactor the program so that the I/O is performed in a function:

```C
        static void file_read(char *file, size_t len);
```
 so that the function is performed in a cycle with 16k iterations and run
 the program with `/etc/passwd`.

 Again run the program under strace to see possible clues.

 Now fix the program so that:
   - it properly detects all errors
   - the function can be called arbitrary number of times (in sequence)

:eyes: [file-open.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/file-open.c)

## Static analysis

- compile time warnings are inherently limited
  - they can detect wide range of errors (format strings, offer missing include
    files, detect simple buffer overflows, ...)

:eyes: [fmt-string-invalid.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/fmt-string-invalid.c)
:eyes: [buf-overflow.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/buf-overflow.c)

  - however fail to cover all corner cases

- static analysis tools hook into compiler and can follow all code paths
  - by constructing graph of code blocks
  - this is useful also for "taint analysis" - following potentially
    unsanitized data input across all code paths to determine if it can be used
    to exploit code deficiencies
  - the method has its drawbacks - false positives, can be foiled somethimes
    because it does not understand enough context and program internals

- Clang: the `scan-build` script is front-end to the library performing checks,
         accepts compilation line as argument
         - the compilation line can be simple compiler invocation and also make

:eyes: [buf-overflow-func.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/buf-overflow-func.c)

  - when compiled with `-Wall -Wextra` no warnings/errors are reported
  - when run, it usually does (depends on compiler/system) not produce any
    warnings and happily prints the corrupted array
    - try to compile with `-DBUFFER_SIZE=128` and the result might be different
      due to stack smashing detection supplied by the compiler
      - if the program is compiled with `-fno-stack-protector` , the stack
	canary is not added and the program normally (sic!) exits with
	segmentation fault
      - try with different compilers (gcc, clang)

Run: `scan-build clang buf-overflow.c`

Note: works with gcc too

Task: write a program that accesses memory allocated on the heap after it is
      freed. See if scan-build static analyzer can detect it.
      Modify the program to return the allocated memory from a function
      and then free + modify it in main. Does scan-build still detect this
      use-after-free bug ?

:eyes: [use-after-free.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/use-after-free.c)

## Library call tracing

- `ltrace` is most widely used tool to print calls to library functions
  - it can provide indentation (`-n`)
  - can be used to do simple profiling (with `-tt`)
- however, it cannot print calls within the program itself
  - this is unlike `truss` that can do it with `-u a.out`

:eyes: [recurs.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/recurs.c)
  - run with: `ltrace -n4 -L ./a.out 5`

Note: `ltrace` can trace system calls as well with the `-S` option

Links:
  - http://techblog.rosedu.org/ltrace.html
  - https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/



## Dynamic analysis

- run-time analysis performed by running the program in an emulation layer
  (virtual machine), intercepting calls to memory allocator etc.
- can provide more detailed detection at the cost of performance and coverage -
  can detect only in the code paths actually executed (compared to static
  analysis)
  - the performance degradation incurred by dynamic analysis is usually
    much higher than the one of syscall/library tracing

Task: Take a look at the code and try to find as many bugs as possible:
:eyes: [shell.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/shell.c)

Then compile the program with as many checks as possible and run the
program through static analysis.

Then run it through Valgrind, perform couple of operations and exit the
program, i.e.

1. `valgrind ./a.out`
1. echo couple of "commands"
1. hit Ctrl-C

Also run it automatically, e.g.:

```
      $ cat << EOF >/tmp/input
foo
bar
foo bar
EOF
      $ valgrind ./a.out < /tmp/input
```

- try to compile the program with debug info (`-g`) and re-run valgrind with
  `--leak-check=full` and see the difference in the output.
- fix the program and re-run the test(s) again

## Dynamic tracing

- dtrace / SystemTap
- should have minimal overhead, mostly can be run on production systems
- provides syscall/library tracing as well as variety of other insights into
  the system (neworking abstractions, CPU performance counters/cache analysis,
  ...)
- allows to ask (before unheard of) questions that could not be answered before
  - e.g. what process is stressing particular disk with I/O, what are the most
    contributing processes that send TCP traffic to port X and what are their
    most frequently executed stack traces, ...

## Asserts

- assert(3)
  - basic implementation of assert, provides run-time condition checking
  - `#define NDEBUG` disables it normally (ie. in the real life the assert
    macro is more complicated.
  - you need `<assert.h>`
  - `assert(0)` is of common use to bail out and to know where it did

Task: write custom assert() macro that prints the line and file information
      (using `__LINE__`, `__FILE__` pre-defined macros) and exits
:eyes: [assert.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/assert.c)

- there is also `#error` pre-processor pragma that can be used to fail during
  compilation phase

- there is static_assert() that is evaluated during compile time however this is
  available only in C++0x
  - it can be handy for things (this is rather a hack) like:
```C
    int i;

    static_assert(sizeof(void *) >= sizeof i);
    foo((void *) i);
```
  - in C99 we can use a array indexing with ternary operator as a check

:eyes: [static_assert.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/static_assert.c)

## Debugger

- can be used for both live debugging and post-mortem analysis (from core file
  produced by the program)
  - works by inserting breakpoints and displaying memory of the process
    - this is usually done using the ptrace(2) syscall
- most common debuggers: gdb, lldb, dbx, mdb
  - some of them have the concept of plug-ins

- compiling for debugging: the `-g` compiler option adds debugging information
  to the resulting binary, in particular mapping of assembly instructions to
  source code lines
  - one can debug without this data, just some assembly knowledge is required

- will describe gdb here

- compile and run the program from gdb:
```
  cc -Wall -g random.c
  gdb ./a.out
  > r
```
- exiting the debugger:
```
  > quit
```
  - or Ctrl-D

- to get the core file, the system limit for core file may need to be bumped
```
  ulimit -c 1000000
```

  - and re-run the program again

- display the stack trace at the moment of breakpoint stop/crash:

```
  > backtrace
```

- see where exactly it crashed:

```
  > disassembly
  > info reg
  > list
```

- insert breakpoint

```
  > b main
  > b run
```

  - can also insert breakpoint to particular line (if the program was compiled
    with line information):

```
  > b 8
```

  - print breakpoints:

```
    > info breakpoints
```

- stepping
  - single line (assembly instruction) stepping:

```
    > next
```

  - step through:

```
    > step
```

- printing memory

  - print variable value:

```
    > print idx
    > print p
```

  - can use the usual dereference/ref operators:
    (once inside run())

```
    > print *p[idx]
```

- print a variable in each step:

```
  > display i
```

  - to disable the printing:

```
    > delete display i
```

- breakpoints can be conditional:

```
  > break 14 if i == idx
```


# Opaque structures

It is possible to declare structure in a header file along with API that
consumes it:

```C
// foo.h
struct foo;
void doStuff(struct foo *f);
```

the file implementing `doStuff()` will contain:

```C
struct foo {
    int x;
    int y;
};

void
doStuff(struct foo *f)
{
	f->x = ...
	f->x = ...
}
```

Then any `.c` file that includes `foo.h` can work with the structure
(by passing it to `doStuff()`) however cannot access its members directly.
The structure is usable only via pointer. Thus, the library has to provide
a function to allocate a structure and return the pointer to it
(and possibly also to initialize it) and functions to get/set the data
inside the structure.

This is handy for libraries so they are free to change the layout of structures
without breaking the consumers.

code:
  - :eyes: [foo.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo.h)
  - :eyes: [foo.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo.c)
  - :eyes: [foo-user.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo-user.c)

# Flexible array member

- since C99 (§6.7.2.1, item 16, page 103)
- it is an array without a dimension specified that is the last member of the
  structure
  - this is handy for structures with a fixed header and "padding" data of
    flexible length that is allocated dynamically
  - why not to use a pointer instead ? this is good when passing data over
    boundaries such as network, kernel/userland, etc. since no deep
    structure copy is required
    - just copy the structure as whole (it is just necessary to know how
      large it is) because it is all contiguous memory

- e.g.:
```C
struct item {
	int value;
	// possible other members
	char payload[];
	// nothing can follow
};
```

- `sizeof (struct item)` will give the size without the last member computed

```
+-------------+-----------------------+
| struct item |      payload ...      |
+-------------+-----------------------+
```

- previously, this was hacked around using array with 0 members and GCC accepted
  this. Since C99 this can be done properly using this technique.
- the data is allocated like so:

```C
struct item *p = malloc(sizeof (struct item) + payload_len * sizeof (p->payload[0]));
```

- with this approach the overall structure alignment might be lost
  - i.e. it is necessary to set the payload length according to the size
    of the structure if you want to maintain alignment

code: :eyes: [flexible-array-member.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/flexible-array-member.c)

# Structure bit fields

- sometimes memory is scarce (imagine having to keep millions of big
  structures in memory) and there are members holding integer values that occupy
  just a couple of bytes
  - bit fields can be used to shrink the memory needed

```C
struct foo {
	unsigned int a : 3;
	unsigned int b : 1;
	unsigned int   : 4;
};
```

- the number after the colon specifies the number of bits for given bit field
  - cannot exceed the size of the underlying data type (`unsigned int` in the
    above example)
- cannot use `sizeof` on bitfield

- this is good for implementing network protocol headers or HW registers,
  however the layout of bit fields in C structure is implementation dependent
  - if it needs to match a concrete layout, additional non-standard compiler
    features have to be used (`#pragma`'s etc.)
  - there is no `offsetof()` for bit fields

code: :eyes: [bitfield.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/bitfield.c)

- the integer values will behave as expected, e.g.

```C
unsigned int a : 3;

a = 7;
a++; // will wraparound to 0 since this is unsigned
```


# :wrench: Warm-up/home task: alternating bits detection

Task: detect if an integer has alternating bits, e.g. `10101`

Note: this can be done in O(1) time using bit operations + arithmetics

