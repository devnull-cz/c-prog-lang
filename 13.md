# Incomplete types

An *incomplete type* is a type that describes an object but lacks information
needed to determine its size.

```
$ cat main.c
struct x a;

int
main(void)
{
}

$ cc main.c
main.c:1:10: error: tentative definition has type 'struct x' that is never
      completed
struct x a;
         ^
main.c:1:8: note: forward declaration of 'struct x'
struct x a;
       ^
1 error generated.
```

The `x` structure could be completed, for all declarations of that type, by
declaring the same structure tag with its defining content later in the same
scope.

BTW, the `void` type is an incomplete type that can be never completed.

Now, you can always work with pointers to an incomplete type.  The following
will compile and run fine.

```C
#include <stdio.h>

struct x *
myfn(struct x *p)
{
        return (p);
}

int
main(void)
{
        myfn(NULL);
}
```

This feature of the C language is used to represent opaque handles.

# Opaque structures

It is possible to declare structure in a header file along with API that
consumes it:

```C
// foo.h
struct foo;
void doStuff(struct foo *f);
```

the file implementing `doStuff()` will contain:

```C
struct foo {
    int x;
    int y;
};

void
doStuff(struct foo *f)
{
	f->x = ...
	f->x = ...
}
```

Then any `.c` file that includes `foo.h` can work with the structure
(by passing it to `doStuff()`) however cannot access its members directly.
The structure is usable only via pointer. Thus, the library has to provide
a function to allocate a structure and return the pointer to it
(and possibly also to initialize it) and functions to get/set the data
inside the structure.

This is handy for libraries so they are free to change the layout of structures
without breaking the consumers.

code:
  - :eyes: [foo.h](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo.h)
  - :eyes: [foo.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo.c)
  - :eyes: [foo-user.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/foo-user.c)

