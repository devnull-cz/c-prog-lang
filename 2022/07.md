# Leftovers from 2022-03-21

# File API

Part of the standard since C90.

## Opening/closing

- `fopen("path", "mode")` opens a file and returns a pointer to an opaque `FILE`
  type.  That pointer serves as a handle.
	- getting `NULL` means an error
	- the `mode` argument controls the behavior: read (`r`), write (`w`),
	  append (`a`)
		- the `+` adds the other mode (write for read and vice versa,
		  read for append).
	  - write mode `w` creates the file if it does not exist, and truncates
	    it if it does exist
	  - the `b` binary mode usually does not have any effect (see
[the standard)](https://github.com/devnull-cz/c-prog-lang/blob/master/modules/c99-standard.md)
	- `fclose` closes the handle
		  - important to avoid resource leak (`fopen` can allocate both
		    memory and file descriptor)
- `freopen` can be used to associate the standard streams (`stderr`, `stdin`, or
  `stdout`) with a file

:wrench: write a code that opens the same file in an cycle (until `fopen()`
fails) without calling `fclose()` on the handle. After how many iterations does
it fail on your system?

:eyes: [fopen-leak.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/fopen-leak.c)

## I/O

- `fprintf` - `printf` to a stream
- `fscanf`
	  - basically parses text input from a stream according to format string
	  - except the format string all the parameters must be pointers
- `fputs`/`fgets` - send/read string to/from a stream
- `fputc`/`fgetc` - send/read `char` to/from a stream

- `fwrite`/`fread` - for writing/reading binary data (such as structures or raw
  numeric types)

## Read a file

`fread`() reads a selected number of items of a given size to memory.  We can
use either an array or we can directly read to a variable through an operator
address-of.  In our case, we will be reading a file byte by byte, so we can give
`fread`() just an address of a character variable.

```C
char c;
FILE *fp;

/* Choose any other file you have on your system. */
if ((fp = fopen("/etc/passwd", "r")) == NULL)
	err(1, "fopen");

/*
 * fread() returns a number of *items* read.  In our case, it's the same as
 * number of bytes as we read it one byte at a time.
 */
while (fread(&c, sizeof (c), 1, fp) == 1) {
	putchar(c);
}

fclose(fp);
```

:eyes: [read-file.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/read-file.c)

:wrench: Note that you could read more characters at a time.  However, keep in
mind the 2nd argument is size of the element read, and the 3rd argument is how
many elements we read in one call.  For example:

```C
char a[16];
...
while ((n = fread(a, 1, sizeof (a), fp)) > 0) {
	/* process the bytes here */

	/* if we read less than requested, we hit end of file */
	if (n < sizeof (a))
		break;
}
```

Check the solution here:
:key: [read-file2.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/read-file2.c)

Also check manual page for `fread`() and ignore for now that the 1st argument is
of type `void *`, we will get there later.  As mentioned above, you can safely
put there an array or an address of a variable.

:wrench: Check the man page for `fwrite`() and modify the code so that what is
read from the file you write to some other file.  Do not remember to open the
output file for writing.  All the details are in the man page.

## Seeking

When reading/writing to a file using the above function, the current position
changes accordingly.  However, the position can be manipulated without
performing any I/O.

- `fseek` - moves the position
	- the `whence` parameter has 3 possible values and makes the `offset`
	  parameter relative to:
		- `SEEK_SET` - the beginning of the file
		- `SEEK_END` - the end of the file
		- `SEEK_CUR` - the current location of the cursor in the file
- `ftell` - get current position in the file


# :wrench: Home assignment

Note that home assignments are entirely voluntary but writing code is the only
way to learn a programming language.

## File of integers

:wrench: get a file size using the standard IO API (that is, `lseek(2)` is
prohibited even if you know it).

:wrench: create array of `int` values (of arbitrary positive length with values
ranging from `INT_MAX` to `0`), write the array to a file, read the values
into another array and print them to the standard error.
Between the writing and reading the file handle has to remain open. Use the
same file handle for reading and writing.
Use `od(1)` to verify the content of the file (thus it is handy to start with
`INT_MAX` and e.g. divide by 2 for each successive value).

:key: [fopen-binary.c](https://github.com/devnull-cz/c-prog-lang/blob/master/src/fopen-binary.c)

:wrench: use the file created by the previous program. Read the values from the
end of the file to the beginning of the file one by one without knowing the file
size and print the numbers to the standard error output.

## File read

:wrench: create a text file where each line begins with integer followed
by space and a string, e.g.:
```
42 towel
13 dwarfs and Snow White
```
Read the file using `fscanf()` and print the values (i.e. integer and a string)
from each line to standard output.

